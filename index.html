<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>정보처리기사 실기 퀴즈</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .chapter-btn {
            transition: all 0.2s ease-in-out;
        }
        .chapter-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .option-btn {
            transition: all 0.2s ease-in-out;
            border-width: 2px;
        }
        .option-btn.correct {
            background-color: #d1fae5;
            border-color: #10b981;
            color: #065f46;
        }
        .option-btn.incorrect {
            background-color: #fee2e2;
            border-color: #ef4444;
            color: #991b1b;
        }
        .disabled {
            pointer-events: none;
            opacity: 0.8;
        }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center min-h-screen p-4">

    <div id="app-container" class="bg-white rounded-2xl shadow-xl w-full max-w-2xl mx-auto overflow-hidden">
        
        <!-- 단원 선택 화면 -->
        <div id="chapter-selection-screen">
            <header class="p-6 bg-indigo-600 text-white">
                <h1 class="text-2xl font-bold">정보처리기사 실기 퀴즈</h1>
                <p class="text-indigo-200 mt-1">학습할 단원을 선택하세요.</p>
            </header>
            <main id="chapter-list" class="p-6 grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- JavaScript로 단원 버튼 생성 -->
            </main>
        </div>

        <!-- 퀴즈 화면 -->
        <div id="quiz-screen" class="hidden">
            <header class="p-6 bg-indigo-600 text-white">
                <h1 id="quiz-header-title" class="text-2xl font-bold"></h1>
                <div class="flex justify-between items-center mt-2">
                    <p id="progress-text" class="text-indigo-200"></p>
                    <button id="back-to-chapters-btn" class="text-sm bg-white/20 hover:bg-white/30 px-3 py-1 rounded-md">단원 선택</button>
                </div>
            </header>
            <main class="p-6">
                <div id="question-container">
                    <p id="question-text" class="text-lg font-semibold leading-relaxed mb-6"></p>
                    <div id="options-container" class="space-y-3">
                        <!-- JavaScript로 보기 버튼 생성 -->
                    </div>
                </div>
                <div id="feedback-container" class="mt-6">
                    <p id="feedback-text" class="text-base font-bold min-h-[24px]"></p>
                </div>
                <button id="next-question-btn" class="w-full bg-indigo-600 text-white font-bold py-3 rounded-lg mt-4 hover:bg-indigo-700 transition-colors hidden">
                    다음 문제
                </button>
            </main>
        </div>

        <!-- 결과 화면 -->
        <div id="result-screen" class="hidden">
            <header class="p-6 bg-indigo-600 text-white">
                <h1 class="text-2xl font-bold">퀴즈 결과</h1>
            </header>
            <main class="p-8 text-center">
                <p class="text-xl mb-2">수고하셨습니다!</p>
                <p id="score-text" class="text-4xl font-bold text-indigo-600 mb-8"></p>
                <div class="flex gap-4">
                    <button id="restart-quiz-btn" class="flex-1 bg-indigo-600 text-white font-bold py-3 rounded-lg hover:bg-indigo-700 transition-colors">
                        다시 풀기
                    </button>
                    <button id="go-to-chapters-btn" class="flex-1 bg-slate-200 text-slate-800 font-bold py-3 rounded-lg hover:bg-slate-300 transition-colors">
                        단원 선택
                    </button>
                </div>
            </main>
        </div>

    </div>

    <script>
        const quizData = [
            {
                "chapter": "응용 SW 기초 기술 활용",
                "exams": [
                    { "exam": "운영체제의 핵심 기능으로, 여러 프로세스가 한정된 CPU 자원을 효율적으로 나누어 사용하도록 스케줄링하고 관리하는 기능은 무엇인가?", "answer": "프로세스 관리" },
                    { "exam": "물리적인 하드웨어 하나를 여러 개의 논리적인 단위로 분할하여, 마치 여러 대의 서버가 동작하는 것처럼 보이게 하는 기술은?", "answer": "가상화" },
                    { "exam": "개발자가 애플리케이션 개발과 배포에만 집중할 수 있도록 OS, 미들웨어, 런타임 등의 플랫폼 환경을 서비스 형태로 제공하는 클라우드 모델은?", "answer": "PaaS" },
                    { "exam": "데이터베이스에서 데이터의 일관성과 무결성을 유지하기 위해 테이블 구조를 체계적으로 분석하고 분해하는 과정은 무엇인가?", "answer": "정규화" },
                    { "exam": "SQL의 DDL(데이터 정의어)에 해당하며, 기존 테이블의 구조(열 추가/삭제, 타입 변경 등)를 수정하는 명령어는?", "answer": "Alter" },
                    { "exam": "SQL의 DCL(데이터 제어어)에 해당하며, 특정 사용자에게 부여했던 테이블 조회나 수정 권한을 회수하는 명령어는?", "answer": "Revoke" },
                    { "exam": "OSI 7계층 중, IP 주소를 사용하여 데이터 패킷의 최적 경로를 결정하고, 다른 네트워크로 데이터를 전송하는 역할을 담당하는 계층은?", "answer": "네트워크 계층" },
                    { "exam": "OSI 7계층 중, 종단 간 통신의 신뢰성을 확보하고 데이터의 흐름 제어, 오류 제어 등을 수행하는 계층은?", "answer": "전송 계층" },
                    { "exam": "여러 네트워크 장비를 거쳐 데이터가 전송될 때, 감쇠된 신호를 증폭하여 더 먼 거리까지 도달할 수 있도록 하는 네트워크 장비는?", "answer": "리피터" },
                    { "exam": "사용자가 텍스트 기반의 명령어를 직접 입력하여 시스템과 상호작용하는 인터페이스 방식을 무엇이라고 하는가?", "answer": "CLI" },
                    { "exam": "데이터베이스에서 데이터의 일관성, 정확성, 유효성을 유지하기 위한 제약 조건들의 집합을 무엇이라고 하는가?", "answer": "무결성" },
                    { "exam": "SQL에서 두 개 이상의 `SELECT` 문의 결과를 합칠 때, 중복된 행을 포함하여 모든 결과를 반환하는 집합 연산자는?", "answer": "UNION ALL" },
                    { "exam": "TCP 프로토콜과 달리, 데이터 전송 전 연결 설정 과정이 없어 속도가 빠르지만 신뢰성이 낮은 비연결성 프로토콜은 무엇인가?", "answer": "UDP" },
                    { "exam": "하나의 물리적 네트워크 회선을 여러 사용자가 동시에 공유할 수 있도록, 데이터를 패킷 단위로 분할하여 전송하는 교환 방식은?", "answer": "패킷 교환 방식" },
                    { "exam": "프로세스 스케줄링 알고리즘 중, 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 비선점형 방식은?", "answer": "SJF(Shortest Job First)" },
                    { "exam": "프로세스가 앞으로 사용할 자원을 미리 선언하여 교착상태를 예방하는 기법은?", "answer": "교착상태 예방" },
                    { "exam": "운영체제가 메모리의 특정 영역에 다른 프로세스가 접근하지 못하도록 보호하는 메모리 관리 기법은?", "answer": "메모리 보호" },
                    { "exam": "물리 메모리보다 큰 용량의 프로그램을 실행할 수 있도록, 보조기억장치를 주 기억장치처럼 사용하는 기술은?", "answer": "가상 메모리" },
                    { "exam": "클라우드 서비스 중, 사용자가 필요로 하는 소프트웨어를 웹을 통해 구독 형태로 제공하는 모델은?", "answer": "SaaS" },
                    { "exam": "제2정규형은, 테이블이 제1정규형을 만족하고, 부분적 함수 종속을 모두 제거한 상태여야 한다. 여기서 '부분적 함수 종속'이란 무엇을 의미하는가?", "answer": "기본키의 일부에만 종속되는 속성이 있는 경우" },
                    { "exam": "트랜잭션의 ACID 특성 중, 트랜잭션이 실행되는 동안에는 다른 트랜잭션이 중간 결과에 접근할 수 없음을 보장하는 성질은?", "answer": "고립성(Isolation)" },
                    { "exam": "OSI 7계층 중, 데이터의 암호화, 압축, 그리고 데이터 표현 방식을 통일하는 역할을 담당하는 계층은?", "answer": "표현 계층" },
                    { "exam": "논리 주소인 IP 주소를 물리 주소인 MAC 주소로 변환하는 프로토콜은?", "answer": "ARP" },
                    { "exam": "네트워크 상에서 동적으로 IP 주소 및 기타 구성 정보를 할당해주는 프로토콜은?", "answer": "DHCP" },
                    { "exam": "웹 페이지를 전송하기 위해 사용되는 대표적인 응용 계층 프로토콜은?", "answer": "HTTP" },
                    { "exam": "여러 개의 프로세스가 공유 자원에 동시에 접근하려 할 때, 한 번에 하나의 프로세스만 접근하도록 제어하는 기법은?", "answer": "상호 배제(Mutual Exclusion)" },
                    { "exam": "프로세스가 생성되어 실행 대기 상태(Ready)에 있는 프로세스들 중에서, CPU를 할당받을 프로세스를 선택하는 스케줄러는?", "answer": "단기 스케줄러" },
                    { "exam": "고정 분할 메모리 할당 방식에서, 분할된 공간보다 큰 프로그램은 적재될 수 없고, 작은 프로그램이 적재되면 남는 공간이 발생하는 현상은?", "answer": "내부 단편화" },
                    { "exam": "가상 메모리에서 페이지 교체 알고리즘 중, 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식은?", "answer": "LRU(Least Recently Used)" },
                    { "exam": "하나의 서버에 여러 운영체제를 설치하고 동시에 실행할 수 있게 하는 가상화 기술은?", "answer": "서버 가상화" },
                    { "exam": "관계형 데이터베이스에서 데이터의 중복으로 인해 발생할 수 있는 데이터 불일치 문제를 무엇이라고 하는가?", "answer": "갱신 이상(Update Anomaly)" },
                    { "exam": "SQL에서 테이블의 모든 데이터를 삭제하지만 테이블 구조는 남겨두는, `DELETE`보다 빠른 명령어는?", "answer": "TRUNCATE" },
                    { "exam": "트랜잭션이 성공적으로 완료되었음을 데이터베이스에 알리는 명령어는?", "answer": "COMMIT" },
                    { "exam": "OSI 7계층의 데이터 링크 계층에서 사용되는 데이터 전송 단위는?", "answer": "프레임(Frame)" },
                    { "exam": "서로 다른 프로토콜을 사용하는 네트워크를 연결해주는 장비는?", "answer": "게이트웨이" },
                    { "exam": "인터넷과 같은 공중망을 마치 사설망처럼 안전하게 사용할 수 있도록 해주는 기술은?", "answer": "VPN" },
                    { "exam": "프로세스의 상태 중, 프로세스가 CPU를 할당받아 명령을 실행하고 있는 상태는?", "answer": "실행(Running)" },
                    { "exam": "프로세스가 입출력 작업 완료 등 특정 이벤트를 기다리며 실행을 멈춘 상태는?", "answer": "대기(Waiting/Blocked)" },
                    { "exam": "운영체제가 프로세스들을 관리하기 위해 각각의 프로세스에 대해 유지하는 정보 블록은?", "answer": "PCB(Process Control Block)" },
                    { "exam": "CPU 스케줄링 알고리즘 중, 각 프로세스에 동일한 시간 할당량(Time Quantum)을 부여하고, 시간이 지나면 다음 프로세스로 전환하는 선점형 방식은?", "answer": "라운드 로빈(Round Robin)" },
                    { "exam": "가변 분할 메모리 할당 방식에서, 사용되지 않는 작은 메모리 공간들이 누적되어 가용 공간을 확보하지 못하는 현상은?", "answer": "외부 단편화" },
                    { "exam": "물리적인 저장 공간을 하나 이상의 논리적인 단위로 나누어 유연하게 관리하는 스토리지 기술은?", "answer": "스토리지 가상화" },
                    { "exam": "데이터베이스 정규화 과정에서 BCNF(보이스-코드 정규형)는 제3정규형을 만족하면서, 어떤 조건을 추가로 만족해야 하는가?", "answer": "모든 결정자가 후보키여야 한다" },
                    { "exam": "SQL의 DML에 속하며, 테이블에 저장된 기존 데이터의 내용을 변경하는 명령어는?", "answer": "UPDATE" },
                    { "exam": "두 개 이상의 트랜잭션이 특정 자원을 놓고 서로 무한정 기다리는 상태를 무엇이라고 하는가?", "answer": "교착상태(Deadlock)" },
                    { "exam": "OSI 7계층 모델을 단순화한 인터넷 프로토콜 스위트 모델은 일반적으로 몇 개의 계층으로 구성되는가?", "answer": "4계층" },
                    { "exam": "도착지 MAC 주소를 모를 때, 네트워크 내의 모든 호스트에게 프레임을 전송하는 방식을 무엇이라고 하는가?", "answer": "브로드캐스팅" },
                    { "exam": "사용자의 편의를 위해 아이콘이나 메뉴 같은 그래픽 요소를 사용하여 컴퓨터와 상호작용하는 인터페이스는?", "answer": "GUI" },
                    { "exam": "하나의 트랜잭션이 완료되기 전까지는 다른 트랜잭션이 해당 결과를 참조할 수 없다는 ACID의 특성은?", "answer": "고립성(Isolation)" },
                    { "exam": "네트워크 통신에서 오류 검출을 위해 사용되며, 송신 데이터 블록의 끝에 추가되는 중복 검사 코드는?", "answer": "CRC(Cyclic Redundancy Check)" }
                ]
            },
            {
                "chapter": "UI 테스트",
                "exams": [
                    { "exam": "별도의 사용자 테스트 없이, 전문가가 사전에 정의된 사용성 원칙(Heuristics)에 따라 UI의 문제점을 체계적으로 평가하는 방법은?", "answer": "휴리스틱 평가" },
                    { "exam": "실제 제품과 동일하게 동작하는 고수준 프로토타입을 사용하여 사용자의 과업 수행 능력을 측정하고, 학습성, 효율성 등을 정량적으로 평가하는 방법은?", "answer": "성능 평가" },
                    { "exam": "소프트웨어 제품이 주어진 환경과 요구사항에 맞게 변경(수정, 개선, 확장)되는 것이 얼마나 용이한지를 나타내는 품질 특성은?", "answer": "유지보수성" },
                    { "exam": "소프트웨어가 다른 운영체제나 하드웨어 환경으로 이전될 때, 얼마나 적은 수정으로 적용될 수 있는지를 나타내는 품질 특성은?", "answer": "이식성" },
                    { "exam": "실제 서비스나 제품을 출시하기 전, 소규모의 목표 사용자 그룹을 대상으로 비공개로 진행하여 사용성과 문제점을 파악하는 테스트는?", "answer": "파일럿 테스트" },
                    { "exam": "조사 대상이 되는 특정 사용자 그룹(6-12명)을 한자리에 모아 특정 주제에 대해 자유롭게 토론하게 함으로써 다양한 의견과 요구를 수집하는 방법은?", "answer": "포커스 그룹 인터뷰" },
                    { "exam": "소프트웨어 품질 특성 중, 명시된 조건에서 사용될 때 사용자가 얼마나 쉽게 배우고, 사용하고, 이해할 수 있는지를 나타내는 것은?", "answer": "사용성" },
                    { "exam": "ISO/IEC 9126 표준에 따르면, 소프트웨어의 신뢰성을 평가하는 하위 특성에 속하지 않는 것은?", "answer": "이해성" },
                    { "exam": "UI 디자인에서 색상, 타이포그래피, 아이콘 등 시각적 요소들을 일관성 있게 설계하여 사용자에게 통일된 경험을 제공하는 시스템은?", "answer": "디자인 시스템" },
                    { "exam": "사용자의 실제 사용 환경과 맥락 속에서 인터뷰와 관찰을 병행하여 잠재된 요구와 문제점을 깊이 있게 파악하는 연구 방법은?", "answer": "맥락적 인터뷰" },
                    { "exam": "소프트웨어가 명시된 요구사항을 얼마나 정확하고 완전하게 만족시키는지 나타내는 ISO/IEC 9126의 품질 특성은?", "answer": "기능성" },
                    { "exam": "사용자가 특정 과업을 수행하는 동안 생각하는 것을 그대로 말하게 하여, 사용자의 인지 과정을 파악하는 테스트 기법은?", "answer": "사고 발성법(Think Aloud Protocol)" },
                    { "exam": "두 가지 이상의 UI 시안(A/B)을 사용자 그룹에게 무작위로 노출시켜, 어떤 시안이 더 나은 성과를 내는지 통계적으로 검증하는 테스트는?", "answer": "A/B 테스트" },
                    { "exam": "사용자가 시스템과 상호작용하는 과정에서 겪는 긍정적, 부정적 경험을 시간 순서대로 시각화한 지도는?", "answer": "사용자 여정 지도(User Journey Map)" },
                    { "exam": "프로젝트의 목표 사용자를 대표하는 가상의 인물을 구체적인 정보(이름, 직업, 목표 등)와 함께 정의하는 것은?", "answer": "페르소나" },
                    { "exam": "ISO/IEC 9126의 품질 특성 중, 주어진 조건에서 자원을 효율적으로 사용하면서 요구된 성능을 제공하는 능력은?", "answer": "효율성" },
                    { "exam": "사용자가 시스템의 상태를 항상 파악할 수 있도록 적절한 피드백을 제공해야 한다는 제이콥 닐슨의 사용성 원칙은?", "answer": "시스템 상태의 가시성" },
                    { "exam": "실제 세계와 사용자에게 친숙한 단어, 개념을 사용하여 정보를 자연스럽게 표현해야 한다는 제이콥 닐슨의 사용성 원칙은?", "answer": "실제 세계와의 부합" },
                    { "exam": "사용자가 실수로 원하지 않는 기능을 실행했을 때, 쉽게 이전 상태로 돌아갈 수 있는 '비상 탈출구'를 제공해야 한다는 원칙은?", "answer": "사용자 제어 및 자유" },
                    { "exam": "동일한 기능이나 용어, 디자인을 일관되게 사용하여 사용자의 학습 부담을 줄여야 한다는 원칙은?", "answer": "일관성 및 표준" },
                    { "exam": "오류 메시지는 문제점을 정확히 표현하고, 해결책을 건설적으로 제시해야 한다는 원칙은?", "answer": "오류 예방 및 처리" },
                    { "exam": "사용자가 불필요한 정보를 기억할 필요 없이, 필요한 기능과 정보를 화면에 보이도록 설계해야 한다는 원칙은?", "answer": "기억보다는 인식" },
                    { "exam": "초보자와 숙련자 모두를 만족시킬 수 있도록, 시스템 사용의 유연성과 효율성을 높여야 한다는 원칙은?", "answer": "사용의 유연성과 효율성" },
                    { "exam": "불필요한 정보를 제거하고, 중요한 정보만 간결하게 제공하여 디자인을 구성해야 한다는 원칙은?", "answer": "미학적이고 미니멀한 디자인" },
                    { "exam": "사용자가 도움말 없이도 시스템을 사용할 수 있어야 하지만, 필요할 경우 쉽게 찾고 이해할 수 있는 도움말을 제공해야 한다는 원칙은?", "answer": "도움말 및 문서화" },
                    { "exam": "UI 프로토타입 중, 실제 코드 개발 없이 디자인 도구만을 사용하여 실제와 유사한 상호작용을 구현한 것은?", "answer": "하이-피델리티 프로토타입" },
                    { "exam": "사용자의 시선이 화면의 어느 부분에, 얼마나 오래 머무는지 추적하여 사용자의 주의와 관심사를 분석하는 기법은?", "answer": "시선 추적(Eye-Tracking)" },
                    { "exam": "사용자가 웹사이트의 정보 구조를 어떻게 인식하는지 파악하기 위해, 콘텐츠 항목들을 카드에 적어 그룹화하게 하는 방법은?", "answer": "카드 소팅(Card Sorting)" },
                    { "exam": "UI 테스트 계획 시, 테스트의 목표와 범위를 명확히 하고, 평가할 구체적인 항목을 정의하는 단계는?", "answer": "테스트 계획 수립" },
                    { "exam": "UI 테스트의 결과로 도출된 문제점들을 우선순위에 따라 분류하고, 개선 방안을 보고서 형태로 작성하는 단계는?", "answer": "결과 분석 및 보고" },
                    { "exam": "ISO/IEC 9126의 유지보수성 하위 특성 중, 변경이 다른 부분에 미치는 영향을 최소화하며 수정할 수 있는 능력은?", "answer": "안정성" },
                    { "exam": "ISO/IEC 9126의 사용성 하위 특성 중, 사용자가 시스템의 기능을 얼마나 쉽게 배울 수 있는지를 나타내는 것은?", "answer": "학습성" },
                    { "exam": "사용자 경험(UX) 디자인 프로세스의 첫 단계로, 사용자와 비즈니스 요구사항을 이해하고 분석하는 과정은?", "answer": "리서치 및 분석" },
                    { "exam": "제품의 핵심 가치와 사용자에게 제공할 경험의 방향을 설정하는 UX 전략 단계는?", "answer": "UX 컨셉 수립" },
                    { "exam": "다양한 아이디어를 빠르게 시각화하여 구조를 탐색하는 초기 단계의 스케치는?", "answer": "러프 스케치" },
                    { "exam": "실제와 유사한 시각적 디자인과 인터랙션을 적용하여 최종 제품의 모습을 구체화하는 단계는?", "answer": "GUI 디자인" },
                    { "exam": "사용자 인터페이스에서 사용되는 아이콘, 버튼, 입력 필드 등 재사용 가능한 UI 요소의 집합은?", "answer": "UI 컴포넌트" },
                    { "exam": "소프트웨어의 품질 특성과 평가를 위한 국제 표준으로, 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성을 정의한 것은?", "answer": "ISO/IEC 9126" },
                    { "exam": "사용자가 어떤 작업을 수행하는 데 걸리는 시간을 측정하여 UI의 효율성을 평가하는 지표는?", "answer": "과업 성공 시간" },
                    { "exam": "사용자가 특정 과업을 수행하는 동안 발생시키는 오류의 횟수나 유형을 분석하는 평가 지표는?", "answer": "오류율" },
                    { "exam": "테스트 후 설문조사나 인터뷰를 통해 사용자가 UI에 대해 느끼는 주관적인 만족도를 측정하는 지표는?", "answer": "사용자 만족도" },
                    { "exam": "사용자가 도움말 없이 처음으로 특정 기능을 성공적으로 사용하는 비율을 측정하는 지표는?", "answer": "학습 용이성" },
                    { "exam": "시스템이 사용자의 행동에 대해 얼마나 빠르고 적절하게 반응하는지를 평가하는 지표는?", "answer": "응답성" },
                    { "exam": "사용자가 제품/서비스와 상호작용하는 모든 접점(Touchpoint)을 시각화하여 전체적인 경험을 분석하는 도구는?", "answer": "서비스 블루프린트" },
                    { "exam": "사용자가 원하는 정보를 쉽게 찾을 수 있도록 메뉴, 링크, 검색 기능 등을 체계적으로 설계하는 것은?", "answer": "내비게이션 디자인" },
                    { "exam": "제품이나 서비스의 정보 구조를 설계하여 사용자가 콘텐츠를 논리적이고 직관적으로 이해할 수 있도록 하는 것은?", "answer": "정보 아키텍처(IA)" },
                    { "exam": "사용자의 감성적인 측면을 자극하여 긍정적인 경험을 유도하는 디자인 접근 방식은?", "answer": "감성 디자인" },
                    { "exam": "모든 사용자가 동등하게 정보에 접근하고 이용할 수 있도록 보장하는 디자인 원칙은?", "answer": "유니버설 디자인" },
                    { "exam": "사용자가 시스템을 조작하는 데 필요한 물리적, 인지적 노력을 최소화하려는 디자인 원칙은?", "answer": "최소 노력의 원칙" },
                    { "exam": "UI에서 자주 사용되는 패턴(예: 탭, 드롭다운 메뉴)을 일관되게 사용하여 사용자의 학습 부담을 줄이는 것은?", "answer": "디자인 패턴 활용" }
                ]
            },
            {
                "chapter": "화면 구현",
                "exams": [
                    { "exam": "사용자가 제품을 사용하며 느끼는 만족도, 감정, 태도 등 총체적인 경험을 의미하는 용어는?", "answer": "UX" },
                    { "exam": "HTML5에서 문서의 구조적 의미를 명확히 하기 위해 도입된 태그로, `main`, `section`, `article` 등이 이에 해당하는 것은?", "answer": "시맨틱 태그" },
                    { "exam": "장애인이나 고령자 등 신체적, 기술적 조건과 관계없이 모든 사용자가 웹 사이트의 정보에 동등하게 접근할 수 있도록 보장하는 개념은?", "answer": "웹 접근성" },
                    { "exam": "하위 모듈이 아직 개발되지 않은 상태에서 상위 모듈을 테스트하기 위해, 하위 모듈의 기능을 임시로 흉내 내는 가짜 객체를 무엇이라고 하는가?", "answer": "스텁(Stub)" },
                    { "exam": "상위 모듈 없이 하위 모듈을 먼저 테스트하기 위해, 상위 모듈의 호출 및 데이터 전달 역할을 대신 수행하는 테스트용 도구는?", "answer": "드라이버(Driver)" },
                    { "exam": "사용자와 시스템 간의 상호작용을 처리하기 위해 JavaScript에서 사용하는 이벤트 핸들러 중, 사용자가 마우스 버튼을 눌렀을 때 발생하는 이벤트는?", "answer": "onmousedown" },
                    { "exam": "HTML 문서 내에 스타일을 정의하는 방법 중, 특정 `<p>` 태그에만 스타일을 적용하고 싶을 때 가장 적합한 CSS 선택자 유형은?", "answer": "태그 선택자" },
                    { "exam": "화면의 너비에 따라 웹 페이지의 레이아웃과 콘텐츠가 유동적으로 변하도록 설계하는 웹 디자인 기법은?", "answer": "반응형 웹 디자인" },
                    { "exam": "CSS에서 '#' 기호를 사용하여 특정 ID를 가진 HTML 요소 하나에만 스타일을 적용하는 선택자는?", "answer": "ID 선택자" },
                    { "exam": "사용자에게 시각적인 편안함과 가독성을 제공하는 것을 목적으로 하는 UI 설계 원칙은?", "answer": "심미성" },
                    { "exam": "사용자가 의도한 기능을 얼마나 쉽고 정확하게 수행할 수 있는지를 나타내는 UI 설계 원칙은?", "answer": "유용성" },
                    { "exam": "정보를 논리적이고 체계적으로 구성하여 사용자가 쉽게 탐색하고 이해할 수 있도록 하는 UI 설계 원칙은?", "answer": "정보 구조" },
                    { "exam": "HTML 문서의 구조와 내용을 정의하는 언어는?", "answer": "HTML" },
                    { "exam": "HTML 요소에 스타일을 적용하여 시각적 표현을 담당하는 언어는?", "answer": "CSS" },
                    { "exam": "웹 페이지에 동적인 기능을 추가하고 사용자와의 상호작용을 구현하는 스크립트 언어는?", "answer": "JavaScript" },
                    { "exam": "HTML 문서의 `<head>` 태그 안에 위치하며, 문서의 제목, 인코딩 방식, 외부 스타일시트 연결 등의 메타데이터를 포함하는 영역은?", "answer": "헤더 영역" },
                    { "exam": "CSS 스타일을 HTML에 적용하는 방법 중, HTML 태그 내에 `style` 속성을 직접 사용하여 적용하는 방식은?", "answer": "인라인 스타일" },
                    { "exam": "CSS 스타일을 `<style>` 태그를 이용하여 HTML 문서 내부에 정의하는 방식은?", "answer": "내부 스타일시트" },
                    { "exam": "CSS 코드를 별도의 `.css` 파일로 분리하여 여러 HTML 문서에서 재사용할 수 있도록 하는 방식은?", "answer": "외부 스타일시트" },
                    { "exam": "CSS 선택자 우선순위에서 가장 높은 우선순위를 가지는 것은?", "answer": "인라인 스타일" },
                    { "exam": "CSS에서 `.` 기호를 사용하여 특정 클래스에 속한 모든 HTML 요소에 스타일을 적용하는 선택자는?", "answer": "클래스 선택자" },
                    { "exam": "JavaScript에서 HTML 문서의 특정 요소를 선택하고 조작하기 위해 사용하는 객체 모델은?", "answer": "DOM(Document Object Model)" },
                    { "exam": "JavaScript에서 특정 이벤트(예: 클릭, 키보드 입력)가 발생했을 때 실행될 함수를 등록하는 것을 무엇이라 하는가?", "answer": "이벤트 리스너" },
                    { "exam": "JavaScript의 이벤트 핸들러 중, 사용자가 키보드의 키를 눌렀을 때 발생하는 이벤트는?", "answer": "onkeydown" },
                    { "exam": "JavaScript의 이벤트 핸들러 중, 사용자가 웹 페이지를 떠나거나 창을 닫으려고 할 때 발생하는 이벤트는?", "answer": "onbeforeunload" },
                    { "exam": "HTML의 `<form>` 요소에서, 사용자가 제출 버튼을 클릭했을 때 발생하는 이벤트는?", "answer": "onsubmit" },
                    { "exam": "HTML5에서 도입된, 웹 페이지의 헤더 영역을 의미하는 시맨틱 태그는?", "answer": "header" },
                    { "exam": "HTML5에서 도입된, 문서의 주요 네비게이션 메뉴를 감싸는 시맨틱 태그는?", "answer": "nav" },
                    { "exam": "HTML5에서 도입된, 문서의 독립적인 주요 콘텐츠 영역을 나타내는 시맨틱 태그는?", "answer": "main" },
                    { "exam": "HTML5에서 도입된, 문서의 바닥글 영역을 의미하며 저작권 정보나 연락처 등을 포함하는 시맨틱 태그는?", "answer": "footer" },
                    { "exam": "CSS 레이아웃 모델 중, 복잡한 레이아웃을 더 쉽고 유연하게 구성할 수 있도록 설계된 1차원 레이아웃 방식은?", "answer": "Flexbox" },
                    { "exam": "CSS 레이아웃 모델 중, 행과 열의 2차원 그리드 시스템을 기반으로 페이지를 정교하게 나눌 수 있는 방식은?", "answer": "Grid" },
                    { "exam": "CSS에서 요소의 위치를 결정하는 `position` 속성의 값 중, 부모 요소를 기준으로 위치를 지정하는 것은?", "answer": "absolute" },
                    { "exam": "CSS에서 요소의 위치를 브라우저 창 기준으로 고정시키는 `position` 속성의 값은?", "answer": "fixed" },
                    { "exam": "사용자 인터페이스(UI)와 사용자 경험(UX)의 관계에 대한 설명으로 가장 적절한 것은?", "answer": "좋은 UX를 위해 좋은 UI가 필요하다" },
                    { "exam": "다양한 화면 크기를 가진 디바이스에 대응하기 위해, 유동적인 그리드와 미디어 쿼리를 사용하는 웹 디자인 접근법은?", "answer": "반응형 웹 디자인" },
                    { "exam": "JavaScript에서 비동기 작업을 처리하기 위해 사용되며, 작업의 성공 또는 실패와 그 결과 값을 나타내는 객체는?", "answer": "Promise" },
                    { "exam": "서버와 비동기적으로 데이터를 교환하여, 페이지 전체를 새로고침하지 않고 일부만 동적으로 갱신하는 웹 개발 기법은?", "answer": "AJAX" },
                    { "exam": "JavaScript의 데이터 타입 중, 하나의 변수에 여러 개의 값을 순서대로 저장할 수 있는 객체는?", "answer": "배열(Array)" },
                    { "exam": "JavaScript에서 `key-value` 쌍으로 데이터를 저장하는 데이터 구조는?", "answer": "객체(Object)" },
                    { "exam": "JavaScript에서 변수 선언 시, 재할당은 가능하지만 재선언은 불가능한 키워드는?", "answer": "let" },
                    { "exam": "JavaScript에서 변수 선언 시, 재할당과 재선언이 모두 불가능한 상수를 선언하는 키워드는?", "answer": "const" },
                    { "exam": "HTML에서 사용자의 입력을 받기 위한 태그로, 텍스트, 비밀번호, 체크박스 등 다양한 형태를 가질 수 있는 것은?", "answer": "input" },
                    { "exam": "웹 접근성 지침(WCAG)에서, 모든 사용자가 콘텐츠를 인식할 수 있어야 한다는 원칙은?", "answer": "인식의 용이성" },
                    { "exam": "웹 접근성 지침(WCAG)에서, 모든 사용자가 UI 컴포넌트를 조작하고 탐색할 수 있어야 한다는 원칙은?", "answer": "운용의 용이성" },
                    { "exam": "CSS에서 스타일 규칙의 적용 범위를 제한하고 다른 요소와의 충돌을 방지하기 위한 방법론은?", "answer": "BEM(Block, Element, Modifier)" },
                    { "exam": "통합 테스트 방식 중, 모든 컴포넌트를 한 번에 결합하여 테스트하는 방식은?", "answer": "빅뱅 테스트" },
                    { "exam": "점진적으로 컴포넌트를 결합하며 테스트를 진행하는 방식 중, 상위에서 하위로 진행하는 것은?", "answer": "하향식 통합 테스트" },
                    { "exam": "UI 설계의 일관성을 유지하고 개발 효율성을 높이기 위해, 재사용 가능한 UI 컴포넌트와 스타일 가이드를 모아놓은 시스템은?", "answer": "디자인 시스템" },
                    { "exam": "JavaScript에서 화살표(=>)를 사용하여 함수를 더 간결하게 표현하는 문법은?", "answer": "화살표 함수(Arrow Function)" }
                ]
            },
            {
                "chapter": "프로그래밍 언어 활용",
                "exams": [
                    { "exam": "데이터 요소들이 메모리 상에서 순차적으로 저장되지 않고, 포인터를 통해 논리적 순서로 연결된 자료구조는?", "answer": "연결 자료 구조" },
                    { "exam": "컴파일 시점에 변수의 타입이나 속성이 결정되는 '정적 바인딩'과 달리, 프로그램 실행 시점에 속성이 결정되는 바인딩 방식은?", "answer": "동적 바인딩" },
                    { "exam": "하나의 연산자나 메서드가 서로 다른 클래스의 객체에 대해 각각 다르게 동작하도록 구현하는 객체지향의 핵심 원리는?", "answer": "다형성" },
                    { "exam": "소스 코드 전체를 한 번에 기계어로 변환하는 '컴파일 언어'와 달리, 코드를 한 줄씩 해석하며 바로 실행하는 언어 번역 방식은?", "answer": "인터프리터 언어" },
                    { "exam": "객체지향 프로그래밍에서 관련 있는 데이터(속성)와 기능(메서드)을 하나의 캡슐로 묶어 외부로부터 데이터를 보호하는 기법은?", "answer": "캡슐화" },
                    { "exam": "C언어에서 파생되어 객체지향 개념을 추가한 언어로, 시스템 프로그래밍과 게임 개발 등에서 높은 성능을 보이는 언어는?", "answer": "C++" },
                    { "exam": "플랫폼 독립적인 실행을 위해 컴파일 시 바이트 코드(.class 파일)를 생성하고, 이를 가상 머신(JVM)에서 실행하는 언어는?", "answer": "Java" },
                    { "exam": "특정 작업을 반복적으로 수행하기 위해 함수가 자기 자신을 다시 호출하는 프로그래밍 기법은?", "answer": "재귀 호출" },
                    { "exam": "프로그램의 흐름을 제어하는 구조 중, 특정 조건이 참(true)인 동안에만 코드 블록을 반복 실행하는 제어문은?", "answer": "반복문(Loop)" },
                    { "exam": "선입선출(FIFO) 원칙에 따라 데이터를 관리하는 자료구조는?", "answer": "큐(Queue)" },
                    { "exam": "후입선출(LIFO) 원칙에 따라 데이터를 관리하는 자료구조는?", "answer": "스택(Stack)" },
                    { "exam": "특정 문제를 해결하기 위한 단계적인 절차나 명령어의 집합을 무엇이라고 하는가?", "answer": "알고리즘" },
                    { "exam": "알고리즘의 성능을 평가하는 척도 중, 입력 데이터의 크기에 따라 연산 횟수가 어떻게 변하는지를 나타내는 것은?", "answer": "시간 복잡도" },
                    { "exam": "알고리즘이 실행되는 동안 사용하는 메모리 공간의 양을 나타내는 성능 척도는?", "answer": "공간 복잡도" },
                    { "exam": "객체지향 프로그래밍에서, 공통된 속성과 행위를 가지는 객체들을 생성하기 위한 '틀' 또는 '설계도'는?", "answer": "클래스(Class)" },
                    { "exam": "클래스로부터 생성되어 고유한 속성 값과 상태를 가지는 실체를 무엇이라고 하는가?", "answer": "객체(Object)" },
                    { "exam": "부모 클래스의 기능을 자식 클래스가 그대로 물려받아 재사용하거나 확장하는 객체지향의 특징은?", "answer": "상속" },
                    { "exam": "외부에서는 객체 내부의 데이터를 직접 접근할 수 없도록 하고, 오직 공개된 메소드를 통해서만 접근을 허용하는 원칙은?", "answer": "정보 은닉" },
                    { "exam": "프로그램의 특정 부분에서만 유효한 변수의 범위를 무엇이라고 하는가?", "answer": "스코프(Scope)" },
                    { "exam": "정렬 알고리즘 중, 가장 간단하지만 데이터가 많아질수록 효율이 급격히 떨어지는 방식은?", "answer": "버블 정렬(Bubble Sort)" },
                    { "exam": "정렬되지 않은 부분에서 가장 작은 원소를 선택하여 정렬된 부분의 끝에 추가하는 방식의 정렬 알고리즘은?", "answer": "선택 정렬(Selection Sort)" },
                    { "exam": "기준점(pivot)을 설정하고, 기준보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할한 후 재귀적으로 정렬하는 빠른 정렬 알고리즘은?", "answer": "퀵 정렬(Quick Sort)" },
                    { "exam": "비선형 자료구조 중, 하나의 루트 노드에서 시작하여 여러 개의 자식 노드가 계층적으로 연결된 구조는?", "answer": "트리(Tree)" },
                    { "exam": "트리 구조에서, 더 이상 자식 노드가 없는 노드를 무엇이라고 하는가?", "answer": "리프 노드(Leaf Node)" },
                    { "exam": "비선형 자료구조 중, 정점(Vertex)과 그 정점을 연결하는 간선(Edge)으로 구성된 네트워크 모델은?", "answer": "그래프(Graph)" },
                    { "exam": "프로그래밍 언어의 문법 규칙을 정의하고, 소스 코드가 이 규칙에 맞는지 검사하는 과정을 무엇이라고 하는가?", "answer": "구문 분석(Parsing)" },
                    { "exam": "고급 언어로 작성된 소스 코드를 컴퓨터가 이해할 수 있는 저급 언어(기계어)로 변환하는 프로그램은?", "answer": "컴파일러" },
                    { "exam": "C언어에서 메모리 주소를 직접 저장하고 조작할 수 있는 변수 타입은?", "answer": "포인터(Pointer)" },
                    { "exam": "시간 복잡도를 표기하는 방법 중, 알고리즘의 최악 실행 시간을 나타내는 표기법은?", "answer": "빅오 표기법(Big-O Notation)" },
                    { "exam": "이미 계산된 결과를 임시로 저장해두고, 동일한 계산이 필요할 때 다시 계산하지 않고 저장된 값을 사용하는 최적화 기법은?", "answer": "메모이제이션(Memoization)" },
                    { "exam": "추상 클래스나 인터페이스와 달리, 객체를 생성할 수 있는 완전한 클래스를 무엇이라고 하는가?", "answer": "콘크리트 클래스(Concrete Class)" },
                    { "exam": "객체지향에서, 상위 타입의 객체를 하위 타입의 객체로 대체해도 프로그램의 정확성이 깨지지 않아야 한다는 원칙은?", "answer": "리스코프 치환 원칙(LSP)" },
                    { "exam": "클래스는 단 하나의 책임만 가져야 한다는 객체지향 설계 원칙은?", "answer": "단일 책임 원칙(SRP)" },
                    { "exam": "클라이언트는 자신이 사용하지 않는 인터페이스에 의존 관계를 맺으면 안 된다는 객체지향 설계 원칙은?", "answer": "인터페이스 분리 원칙(ISP)" },
                    { "exam": "상위 모듈이 하위 모듈에 의존해서는 안 되며, 둘 모두 추상화에 의존해야 한다는 객체지향 설계 원칙은?", "answer": "의존관계 역전 원칙(DIP)" },
                    { "exam": "소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 원칙은?", "answer": "개방-폐쇄 원칙(OCP)" },
                    { "exam": "프로그래밍 언어에서 기본적으로 제공하는 데이터 타입(int, char, float 등)을 무엇이라고 하는가?", "answer": "원시 타입(Primitive Type)" },
        
                    { "exam": "웹 개발에서 많이 사용되며, 동적인 웹 페이지 제작을 위해 설계된 인터프리터 방식의 스크립트 언어는?", "answer": "Python" },
                    { "exam": "문자열 처리에 강점을 가지며, 유닉스 시스템에서 CGI 스크립트 작성에 널리 사용되었던 언어는?", "answer": "Perl" },
                    { "exam": "함수형 프로그래밍의 특징을 가지며, 인공지능 연구 초기에 많이 사용되었던 언어는?", "answer": "LISP" },
                    { "exam": "논리 기반의 프로그래밍 언어로, 전문가 시스템이나 인공지능 분야에서 사용되는 언어는?", "answer": "Prolog" },
                    { "exam": "자료구조 중, 키(Key)와 값(Value)을 하나의 쌍으로 저장하며, 키를 이용해 빠르게 값을 탐색할 수 있는 구조는?", "answer": "해시 테이블(Hash Table)" },
                    { "exam": "정렬된 리스트에서 중간 값과의 비교를 통해 찾고자 하는 데이터의 위치를 빠르게 찾아내는 탐색 알고리즘은?", "answer": "이진 탐색(Binary Search)" },
                    { "exam": "예외(Exception)가 발생했을 때, 프로그램의 비정상적인 종료를 막고 적절한 처리를 하도록 하는 프로그래밍 구문은?", "answer": "예외 처리(Exception Handling)" },
                    { "exam": "메모리 관리 기법 중, 더 이상 사용되지 않는 객체를 자동으로 찾아내어 메모리에서 해제하는 기능은?", "answer": "가비지 컬렉션(Garbage Collection)" },
                    { "exam": "여러 개의 실행 흐름(스레드)이 동시에 작업을 처리하여 시스템의 효율성을 높이는 프로그래밍 모델은?", "answer": "멀티스레딩" },
                    { "exam": "두 스레드가 서로 상대방의 작업이 끝나기만을 기다리며 다음 단계를 진행하지 못하는 교착상태의 한 유형은?", "answer": "경쟁 상태(Race Condition)" },
                    { "exam": "하나의 프로세스 내에서 실행되는 여러 흐름의 단위를 무엇이라고 하는가?", "answer": "스레드(Thread)" },
                    { "exam": "프로그램 코드에서 오류를 찾아내고 수정하는 과정을 무엇이라고 하는가?", "answer": "디버깅(Debugging)" },
                    { "exam": "소스 코드를 다른 개발자가 쉽게 이해할 수 있도록, 코드의 목적이나 동작 방식을 설명하는 글을 무엇이라고 하는가?", "answer": "주석(Comment)" }
                ]
            },
            {
                "chapter": "SQL 활용",
                "exams": [
                    { "exam": "데이터베이스의 논리적 구조와 제약 조건 등을 정의한 것으로, 사용자의 관점에 따라 외부, 개념, 내부 3단계로 나뉘는 것은?", "answer": "스키마" },
                    { "exam": "SQL에서 `JOIN`을 수행할 때, 두 테이블 간에 일치하는 행이 없는 경우에도 한쪽 테이블의 모든 행을 결과에 포함시키는 조인 유형은?", "answer": "외부조인" },
                    { "exam": "데이터베이스에서 여러 사용자가 동시에 데이터를 접근하고 수정할 때 발생하는 문제를 제어하여 데이터의 일관성을 유지하는 기능은?", "answer": "동시성 제어" },
                    { "exam": "하나의 SQL문 내에 포함되어, 바깥쪽 SQL문의 결과를 제한하거나 가공하기 위해 사용되는 또 다른 `SELECT` 문을 무엇이라고 하는가?", "answer": "서브쿼리" },
                    { "exam": "테이블에서 데이터를 더 빨리 찾기 위해 사용하는 B-Tree 구조의 자료구조로, 조회 성능은 향상되지만 삽입/삭제 성능은 저하될 수 있는 것은?", "answer": "인덱스" },
                    { "exam": "트랜잭션이 성공적으로 완료되면 영구적으로 반영되고, 실패하면 이전 상태로 완전히 복귀하는 'All or Nothing' 특성을 무엇이라고 하는가?", "answer": "원자성(Atomicity)" },
                    { "exam": "테이블 내의 모든 행을 유일하게 식별할 수 있는 하나 이상의 열(column)의 집합을 무엇이라고 하는가?", "answer": "기본키(Primary Key)" },
                    { "exam": "한 테이블의 필드(열)가 다른 테이블의 기본키를 참조하여 테이블 간의 관계를 설정하는 키를 무엇이라고 하는가?", "answer": "외래키(Foreign Key)" },
                    { "exam": "`GROUP BY` 절과 함께 사용되며, 그룹화된 결과에 대해 특정 조건을 적용하여 필터링하는 데 사용되는 SQL 절은?", "answer": "HAVING" },
                    { "exam": "트랜잭션의 특성 중, 트랜잭션이 성공적으로 완료되면 그 결과가 시스템 장애에도 불구하고 영구적으로 보존되어야 한다는 성질은?", "answer": "지속성(Durability)" },
                    { "exam": "한 트랜잭션이 실행되는 동안에는 다른 트랜잭션이 중간 결과에 접근할 수 없도록 보장하는 특성은?", "answer": "고립성(Isolation)" },
                    { "exam": "트랜잭션이 실행을 시작하기 전과 후에 데이터베이스의 일관된 상태를 유지해야 한다는 특성은?", "answer": "일관성(Consistency)" },
                    { "exam": "SQL에서 `NULL` 값을 다른 특정 값으로 대체하여 표시하고 싶을 때 사용하는 함수는?", "answer": "COALESCE" },
                    { "exam": "두 테이블을 조인할 때, 양쪽 테이블 모두에 일치하는 행만 반환하는 가장 일반적인 조인 방식은?", "answer": "내부조인(INNER JOIN)" },
                    { "exam": "한 테이블에 존재하는 모든 행을 다른 테이블의 모든 행과 각각 조인하여 거대한 결과 집합을 만드는 조인은?", "answer": "교차조인(CROSS JOIN)" },
                    { "exam": "하나의 속성(attribute)이 가질 수 있는 값의 타입을 정의하고, 제약하는 것을 무엇이라고 하는가?", "answer": "도메인(Domain)" },
                    { "exam": "데이터의 중복을 허용하지 않고, 모든 행을 고유하게 식별하기 위해 사용되는 제약조건은?", "answer": "UNIQUE 제약조건" },
                    { "exam": "테이블의 특정 열에 `NULL` 값이 입력되는 것을 방지하는 제약조건은?", "answer": "NOT NULL 제약조건" },
                    { "exam": "`SELECT` 문에서 특정 열의 중복된 값을 제거하고 고유한 값만 조회하고 싶을 때 사용하는 키워드는?", "answer": "DISTINCT" },
                    { "exam": "SQL에서 `LIKE` 연산자와 함께 사용되며, 임의의 여러 문자를 대체하는 와일드카드 문자는?", "answer": "%" },
                    { "exam": "`ORDER BY` 절에서 정렬 순서를 지정하지 않았을 때, 기본적으로 적용되는 정렬 방식은?", "answer": "오름차순(ASC)" },
                    { "exam": "`GROUP BY`를 사용하여 그룹화한 결과에 대해, 각 그룹의 개수를 세는 데 사용하는 집계 함수는?", "answer": "COUNT()" },
                    { "exam": "사용자의 편의를 위해 자주 사용되는 복잡한 쿼리를 미리 이름 붙여 저장해 둔 객체로, 실제 데이터를 저장하지 않는 가상의 테이블은?", "answer": "뷰(View)" },
                    { "exam": "특정 테이블에 데이터의 삽입, 수정, 삭제 이벤트가 발생했을 때, 자동으로 실행되도록 정의된 프로시저는?", "answer": "트리거(Trigger)" },
                    { "exam": "데이터베이스에 대한 일련의 작업을 정리한 절차를 이름 붙여 저장하고, 필요할 때 호출하여 사용하는 SQL 문의 집합은?", "answer": "저장 프로시저" },
                    { "exam": "정규화 과정 중, 제1정규형(1NF)을 만족하기 위한 조건은?", "answer": "모든 속성 값은 원자 값을 가져야 한다" },
                    { "exam": "정규화 과정 중, 제2정규형(2NF)은 제1정규형을 만족하고 어떤 종속성을 제거해야 하는가?", "answer": "부분 함수적 종속성" },
                    { "exam": "정규화 과정 중, 제3정규형(3NF)은 제2정규형을 만족하고 어떤 종속성을 제거해야 하는가?", "answer": "이행적 함수적 종속성" },
                    { "exam": "`WHERE` 절과 `HAVING` 절의 주된 차이점은?", "answer": "HAVING은 그룹화된 결과에 대한 조건을 지정한다" },
                    { "exam": "데이터베이스의 성능을 저하시키는 비효율적인 SQL을 찾아내고, 이를 개선하여 최적화하는 과정을 무엇이라고 하는가?", "answer": "SQL 튜닝" },
                    { "exam": "SQL 튜닝 시, 옵티마이저가 최적의 실행 계획을 수립할 수 있도록 힌트를 제공하는 것을 무엇이라 하는가?", "answer": "힌트(Hint)" },
                    { "exam": "물리적으로는 여러 곳에 분산되어 있지만, 사용자에게는 하나의 단일한 데이터베이스처럼 보이게 하는 시스템은?", "answer": "분산 데이터베이스" },
                    { "exam": "SQL에서 `SELECT` 문의 결과 집합에 번호를 매기는 등 분석 기능을 제공하는 함수들을 통칭하여 무엇이라고 하는가?", "answer": "윈도우 함수" },
                    { "exam": "트랜잭션 격리 수준 중, 하나의 트랜잭션이 다른 트랜잭션에서 아직 커밋되지 않은 데이터를 읽는 것을 허용하는 가장 낮은 수준은?", "answer": "Read Uncommitted" },
                    { "exam": "다른 트랜잭션이 특정 데이터에 접근하지 못하도록 막는 동시성 제어 기법은?", "answer": "로킹(Locking)" },
                    { "exam": "RDBMS와 달리, 정형화되지 않은 대량의 데이터를 유연하게 처리하는 데 중점을 둔 데이터베이스 시스템은?", "answer": "NoSQL" },
                    { "exam": "`JOIN` 조건에 맞는 행이 없을 때, `LEFT JOIN`은 어느 쪽 테이블의 모든 행을 반환하는가?", "answer": "왼쪽 테이블" },
                    { "exam": "하나의 테이블에서 자기 자신을 조인하여, 계층적인 관계(예: 사원과 관리자)를 표현할 때 사용하는 조인은?", "answer": "셀프 조인(SELF JOIN)" },
                    { "exam": "SQL에서 모든 서브쿼리의 결과가 존재하는지 여부를 확인하는 데 사용되는 연산자는?", "answer": "EXISTS" },
                    { "exam": "데이터베이스 사용자의 접근 권한을 관리하기 위한 SQL 명령어 그룹은?", "answer": "DCL(데이터 제어어)" },
                    { "exam": "물리적인 테이블은 하나지만, 논리적으로 다른 뷰를 제공하여 보안성을 높일 수 있는 데이터베이스 객체는?", "answer": "뷰(View)" },
                    { "exam": "여러 개의 SQL 문을 하나의 논리적인 작업 단위로 묶는 것을 무엇이라고 하는가?", "answer": "트랜잭션" },
                    { "exam": "데이터베이스 옵티마이저가 SQL 실행 계획을 수립할 때 참고하는 통계 정보를 무엇이라고 하는가?", "answer": "카탈로그 정보" },
                    { "exam": "SQL 쿼리에서 `AS` 키워드는 주로 어떤 용도로 사용되는가?", "answer": "열 또는 테이블의 별칭(Alias) 지정" },
                    { "exam": "분산 데이터베이스 환경에서, 모든 노드의 데이터가 일관성을 유지하도록 하는 것은 매우 중요하다. 이와 관련된 문제는?", "answer": "데이터 일관성 문제" },
                    { "exam": "`UNION`과 `UNION ALL`의 가장 큰 차이점은 무엇인가?", "answer": "중복 행 제거 여부" },
                    { "exam": "테이블 생성 시, 특정 열의 값이 미리 정해진 값들 중 하나만 갖도록 하는 제약조건은?", "answer": "CHECK 제약조건" },
                    { "exam": "하나의 트랜잭션이 수정한 데이터를 다른 트랜잭션이 읽을 수 없도록 하는 동시성 제어의 특성은?", "answer": "고립성(Isolation)" },
                    { "exam": "SQL 실행 계획(Execution Plan)이란 무엇인가?", "answer": "SQL을 가장 효율적으로 실행하기 위한 절차 및 방법" },
                    { "exam": "SQL에서 문자열 패턴 매칭을 위해 `LIKE`와 함께 사용하는 와일드카드가 아닌 것은?", "answer": "*" }
                ]
            },
            {
                "chapter": "애플리케이션 테스트 수행",
                "exams": [
                    { "exam": "여러 개의 단위 모듈을 결합하는 과정에서 발생할 수 있는 인터페이스 오류나 상호작용 문제를 검증하는 테스트 단계는?", "answer": "통합 테스트" },
                    { "exam": "개발이 완료된 소프트웨어를 실제 운영 환경과 동일한 환경에서, 최종 사용자가 직접 사용하며 요구사항 만족 여부를 최종 확인하는 테스트는?", "answer": "인수 테스트" },
                    { "exam": "개발자의 코딩 실수나 설계 오류로 인해 소프트웨어 내부에 존재하는 잠재적인 문제를 무엇이라고 하는가?", "answer": "결함" },
                    { "exam": "소프트웨어 내부의 결함으로 인해, 실행 중에 사용자가 예상한 결과와 다른 결과가 나타나는 현상을 무엇이라고 하는가?", "answer": "실패" },
                    { "exam": "테스트 활동 전반에 걸쳐 발견된 결함의 상태(등록, 검토, 수정, 재확인 등)를 추적하고 관리하는 체계적인 프로세스는?", "answer": "결함 관리" },
                    { "exam": "특정 결함의 수정이 즉시 불가능하거나 중요도가 낮아, 다음 릴리즈까지 수정을 연기하기로 결정된 결함의 상태는?", "answer": "결함 조치 보류" },
                    { "exam": "소프트웨어의 내부 구조나 로직을 보지 않고, 오직 요구사항 명세서에 따라 입출력 값을 확인하여 기능의 정확성을 검증하는 테스트 기법은?", "answer": "블랙박스 테스트" },
                    { "exam": "소프트웨어의 내부 소스 코드 구조와 로직을 직접 보면서, 모든 경로가 테스트되었는지 확인하는 구조 기반 테스트 기법은?", "answer": "화이트박스 테스트" },
                    { "exam": "실제 배포 전, 제한된 수의 일반 사용자 그룹에게 소프트웨어를 공개하여 다양한 환경에서의 피드백을 수집하는 테스트는?", "answer": "베타 테스트" },
                    { "exam": "소프트웨어의 특정 기능이나 모듈이 변경되었을 때, 그 변경으로 인해 다른 부분에 예기치 않은 문제가 발생하지 않았는지 확인하는 테스트는?", "answer": "회귀 테스트" },
                    { "exam": "소프트웨어 개발 프로세스의 각 단계가 끝날 때마다, 해당 단계의 산출물을 검토하고 검증하는 활동을 무엇이라고 하는가?", "answer": "정적 테스트" },
                    { "exam": "소프트웨어를 직접 실행하여 기능의 동작 여부와 정확성을 확인하는 테스트 활동은?", "answer": "동적 테스트" },
                    { "exam": "테스트의 목표, 범위, 일정, 자원 등을 명시한 문서로, 테스트 활동의 기준이 되는 것은?", "answer": "테스트 계획서" },
                    { "exam": "특정 요구사항이나 기능을 검증하기 위한 입력 값, 실행 조건, 예상 결과 등을 상세히 기술한 문서는?", "answer": "테스트 케이스" },
                    { "exam": "블랙박스 테스트 기법 중, 유효한 입력 값과 무효한 입력 값의 경계에서 오류가 발생할 확률이 높다는 점을 이용하는 테스트 설계 기법은?", "answer": "경계값 분석" },
                    { "exam": "블랙박스 테스트 기법 중, 유사한 결과를 내는 입력 값들을 하나의 그룹(클래스)으로 묶고, 각 그룹에서 대표 값을 선택하여 테스트하는 기법은?", "answer": "동등 분할" },
                    { "exam": "화이트박스 테스트 기법 중, 프로그램의 모든 문장(Statement)이 적어도 한 번 이상 실행되도록 테스트 케이스를 설계하는 커버리지 기준은?", "answer": "구문 커버리지" },
                    { "exam": "화이트박스 테스트 기법 중, 프로그램 내의 모든 분기점(if, switch 등)이 참과 거짓 모든 경우에 대해 한 번 이상 실행되도록 하는 커버리지 기준은?", "answer": "결정 커버리지" },
                    { "exam": "테스트의 결함을 발견하고 보고하는 것 외에, 소프트웨어의 품질 수준을 객관적으로 평가하고 개선을 유도하는 활동은?", "answer": "품질 보증(QA)" },
                    { "exam": "개발팀 내부에서 비공식적으로 수행되며, 동료들이 서로의 작업 산출물을 검토하고 피드백을 공유하는 검토 회의는?", "answer": "동료 검토" },
                    { "exam": "개발자가 작성한 코드를 다른 검토자들이 공식적인 절차에 따라 검사하고 결함을 찾아내는 정형화된 검토 프로세스는?", "answer": "인스펙션" },
                    { "exam": "개발자가 아닌 독립적인 테스트 팀이 수행하며, 사용자 관점에서 시스템 전체의 동작을 검증하는 테스트는?", "answer": "시스템 테스트" },
                    { "exam": "시스템에 과도한 부하를 가하여, 시스템의 한계 성능과 장애 발생 지점을 확인하는 테스트는?", "answer": "스트레스 테스트" },
                    { "exam": "시스템이 장시간 안정적으로 운영될 수 있는지 확인하기 위해, 오랜 시간 동안 테스트를 수행하는 것은?", "answer": "내구성 테스트" },
                    { "exam": "시스템의 보안 취약점을 찾아내고, 외부의 공격으로부터 시스템을 보호할 수 있는지 확인하는 테스트는?", "answer": "보안 테스트" },
                    { "exam": "시스템 장애 발생 시, 데이터 백업과 복구 절차가 정상적으로 동작하는지 확인하는 테스트는?", "answer": "회복 테스트" },
                    { "exam": "서로 다른 시스템이나 컴포넌트가 얼마나 잘 호환되어 동작하는지를 검증하는 테스트는?", "answer": "호환성 테스트" },
                    { "exam": "테스트 자동화를 위해, 테스트 스크립트를 작성하고 실행하며 결과를 관리하는 데 사용되는 소프트웨어 도구는?", "answer": "테스트 자동화 프레임워크" },
                    { "exam": "결함이 수정된 후, 해당 결함이 실제로 해결되었는지를 확인하는 테스트는?", "answer": "확인 테스트" },
                    { "exam": "결함의 심각도와 우선순위를 결정하는 과정에서, 비즈니스에 미치는 영향과 긴급성을 고려하여 수정 순서를 정하는 활동은?", "answer": "결함 분석 및 분류" },
                    { "exam": "테스트 프로세스가 완료된 후, 테스트 활동의 성과와 발견된 결함의 경향을 분석하여 보고하는 문서는?", "answer": "테스트 결과 보고서" },
                    { "exam": "개발 초기 단계에서 요구사항 명세서나 설계서를 검토하여 결함을 조기에 발견하는 활동의 가장 큰 장점은?", "answer": "결함 수정 비용 감소" },
                    { "exam": "테스트 커버리지란 무엇을 의미하는가?", "answer": "테스트가 소프트웨어의 특정 범위를 얼마나 검증했는지를 나타내는 척도" },
                    { "exam": "단위 테스트를 자동화하기 위해 Java에서 널리 사용되는 테스트 프레임워크는?", "answer": "JUnit" },
                    { "exam": "개발 수명주기 전반에 걸쳐 테스트를 지속적으로 수행하여 결함을 조기에 발견하고 품질을 향상시키는 접근법은?", "answer": "지속적인 테스트" },
                    { "exam": "사용자의 요구사항이 명세서에 올바르게 반영되었는지를 검증하는 활동을 무엇이라고 하는가?", "answer": "확인(Verification)" },
                    { "exam": "개발된 소프트웨어가 실제 사용자의 요구와 기대를 만족시키는지를 검증하는 활동을 무엇이라고 하는가?", "answer": "검증(Validation)" },
                    { "exam": "경험과 직관에 기반하여, 오류가 발생할 가능성이 높은 부분을 집중적으로 테스트하는 기법은?", "answer": "탐색적 테스팅" },
                    { "exam": "오류를 유발할 것 같은 입력 값이나 시나리오를 추측하여 테스트 케이스를 설계하는 기법은?", "answer": "오류 추정" },
                    { "exam": "결함 관리 도구(예: Jira, Mantis)의 주요 기능이 아닌 것은?", "answer": "소스 코드 자동 수정" },
                    { "exam": "소프트웨어의 품질을 측정하고 평가하기 위한 모델 중, 사용의 용이성에 초점을 맞춘 품질 특성은?", "answer": "사용성 테스트" },
                    { "exam": "테스트를 통해 모든 결함을 발견하는 것은 불가능하다는 테스트의 원리는?", "answer": "완벽한 테스팅의 불가능성" },
                    { "exam": "소프트웨어의 결함은 특정 모듈에 집중되는 경향이 있다는 테스트의 원리는?", "answer": "결함 집중의 원리" },
                    { "exam": "동일한 테스트 케이스를 반복적으로 실행하면, 더 이상 새로운 결함을 발견할 수 없게 된다는 테스트의 원리는?", "answer": "살충제 패러독스" },
                    { "exam": "테스트는 결함이 존재함을 보여줄 수는 있지만, 결함이 없음을 증명할 수는 없다는 테스트의 원리는?", "answer": "결함 부재의 궤변" },
                    { "exam": "개발 수명주기의 초기 단계에서 테스트를 시작해야 한다는 원리는?", "answer": "조기 테스팅" },
                    { "exam": "테스트는 개발 상황(context)에 따라 다르게 수행되어야 한다는 원리는?", "answer": "정황 의존성" },
                    { "exam": "알파 테스트와 베타 테스트의 가장 큰 차이점은?", "answer": "테스트 수행 주체 및 환경" },
                    { "exam": "테스트 산출물 중, 테스트의 전반적인 전략과 접근 방식을 기술하는 문서는?", "answer": "테스트 전략서" },
                    { "exam": "요구사항 명세서의 각 항목이 테스트 케이스와 어떻게 연결되는지를 추적하고 관리하는 표는?", "answer": "추적 매트릭스" }
                ]
            },
            {
                "chapter": "애플리케이션 테스트 배포",
                "exams": [
                    { "exam": "HTML, CSS와 같은 정적 콘텐츠 요청은 웹 서버가 처리하고, 복잡한 비즈니스 로직이나 DB 연동과 같은 동적 요청은 WAS가 처리하도록 역할을 분리하는 서버 아키텍처의 주된 이유는?", "answer": "서버 부하 분산 및 안정성 확보" },
                    { "exam": "개발자가 소스 코드를 원격 저장소에 커밋할 때마다 빌드, 테스트, 배포가 자동으로 실행되도록 구성하여 개발 생산성을 높이는 환경을 무엇이라고 하는가?", "answer": "지속적인 통합 환경" },
                    { "exam": "소프트웨어를 실행하지 않고 소스 코드 자체의 구조, 스타일, 잠재적 오류 등을 분석하는 활동을 무엇이라고 하는가?", "answer": "정적 테스트" },
                    { "exam": "소프트웨어 개발 산출물의 모든 변경 이력을 체계적으로 추적하고 통제하여 제품의 일관성을 유지하는 관리 활동은?", "answer": "형상 관리" },
                    { "exam": "자바 기반의 웹 애플리케이션에서 서블릿, JSP, 정적 파일 등을 하나로 묶어 웹 컨테이너에 배포하는 표준 아카이브 파일 형식은?", "answer": "WAR" },
                    { "exam": "여러 개발자가 소스 코드를 공유하고 협업하기 위해 사용하는 시스템으로, 버전 관리 및 변경 이력 추적 기능을 제공하는 것은?", "answer": "버전 관리 시스템" },
                    { "exam": "새로운 버전의 애플리케이션을 배포할 때, 기존 버전과 새 버전을 동시에 운영하면서 일부 트래픽만 점진적으로 새 버전으로 보내는 배포 전략은?", "answer": "카나리 배포" },
                    { "exam": "소스 코드를 컴파일, 테스트, 패키징하여 실행 가능한 애플리케이션으로 만들어주는 과정을 자동화하는 도구(예: Jenkins, Gradle)를 무엇이라고 하는가?", "answer": "빌드 자동화 도구" },
                    { "exam": "애플리케이션과 그 실행에 필요한 모든 라이브러리, 종속성 등을 컨테이너라는 격리된 환경에 패키징하는 기술은?", "answer": "컨테이너화" },
                    { "exam": "리눅스 컨테이너 기술을 기반으로 하는 대표적인 오픈소스 컨테이너화 플랫폼은?", "answer": "도커(Docker)" },
                    { "exam": "배포 전략 중, 기존 버전(블루)과 새로운 버전(그린)의 환경을 각각 독립적으로 구성하고, 라우터를 통해 트래픽을 한 번에 전환하는 방식은?", "answer": "블루-그린 배포" },
                    { "exam": "지속적인 통합(CI) 이후, 변경 사항을 자동으로 테스트 환경이나 운영 환경에 배포하는 과정을 무엇이라고 하는가?", "answer": "지속적인 배포(CD)" },
                    { "exam": "형상 관리에서 특정 시점의 안정된 소프트웨어 버전을 공식적으로 확정하고, 변경을 엄격히 통제하기 위한 기준선을 무엇이라고 하는가?", "answer": "베이스라인(Baseline)" },
                    { "exam": "분산 버전 관리 시스템의 대표적인 예로, 각 개발자가 전체 저장소의 복제본을 가지고 작업하는 방식은?", "answer": "Git" },
                    { "exam": "Git에서 소스 코드의 변경 사항을 로컬 저장소에 기록하는 명령어는?", "answer": "commit" },
                    { "exam": "Git에서 로컬 저장소의 변경 이력을 원격 저장소와 동기화(업로드)하는 명령어는?", "answer": "push" },
                    { "exam": "Git에서 원격 저장소의 최신 변경 이력을 로컬 저장소로 가져와 병합하는 명령어는?", "answer": "pull" },
                    { "exam": "Git에서 독립적인 작업 공간을 생성하여, 기존 코드에 영향을 주지 않고 새로운 기능을 개발하거나 버그를 수정할 때 사용하는 기능은?", "answer": "브랜치(Branch)" },
                    { "exam": "두 개 이상의 브랜치를 하나의 브랜치로 통합하는 Git의 기능은?", "answer": "병합(Merge)" },
                    { "exam": "웹 서버와 WAS를 물리적으로 분리하지 않고, 하나의 서버에서 모두 운영하는 구성 방식을 무엇이라고 하는가?", "answer": "단일 서버 구성" },
                    { "exam": "사용자의 요청을 여러 대의 서버로 분산시켜 부하를 줄이고, 특정 서버에 장애가 발생해도 서비스 중단을 방지하는 기술은?", "answer": "로드 밸런싱" },
                    { "exam": "애플리케이션의 성능을 모니터링하고 분석하여, 문제의 원인을 파악하고 성능을 최적화하는 도구를 무엇이라고 하는가?", "answer": "APM(Application Performance Monitoring)" },
                    { "exam": "소스 코드의 품질을 정적으로 분석하여 버그, 코드 스멜, 보안 취약점 등을 검사하는 대표적인 오픈소스 도구는?", "answer": "SonarQube" },
                    { "exam": "배포된 애플리케이션의 로그를 중앙에서 수집, 분석, 시각화하여 시스템 상태를 모니터링하는 것을 무엇이라고 하는가?", "answer": "로그 관리 시스템" },
                    { "exam": "새로운 기능을 소수의 특정 사용자 그룹에게만 먼저 공개하여 테스트하고, 점차적으로 공개 범위를 확대하는 배포 방식은?", "answer": "기능 플래그(Feature Flag)" },
                    { "exam": "자바 애플리케이션 서버(WAS)의 대표적인 오픈소스 구현체는?", "answer": "Tomcat" },
                    { "exam": "소스 코드를 빌드할 때, 필요한 외부 라이브러리나 모듈을 자동으로 다운로드하고 관리해주는 도구는?", "answer": "의존성 관리 도구" },
                    { "exam": "형상 관리 도구 중, 중앙 집중식 버전 관리 시스템의 대표적인 예는?", "answer": "SVN(Subversion)" },
                    { "exam": "애플리케이션 배포 시, 인프라 구성을 코드로 정의하고 관리하여 수동 작업을 최소화하는 접근법은?", "answer": "IaC(Infrastructure as Code)" },
                    { "exam": "IaC를 구현하는 대표적인 도구로, 서버 구성 및 관리를 자동화하는 것은?", "answer": "Ansible" },
                    { "exam": "배포 과정에서 문제가 발생했을 때, 이전의 안정적인 버전으로 신속하게 되돌리는 작업을 무엇이라고 하는가?", "answer": "롤백(Rollback)" },
                    { "exam": "애플리케이션의 구성 정보(DB 접속 정보, API 키 등)를 소스 코드와 분리하여 관리하는 가장 주된 이유는?", "answer": "보안성 강화 및 설정 유연성 확보" },
                    { "exam": "애플리케이션의 무중단 배포를 위한 전략이 아닌 것은?", "answer": "빅뱅 배포" },
                    { "exam": "컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 오픈소스 시스템은?", "answer": "쿠버네티스" },
                    { "exam": "배포 파이프라인에서, 코드 변경 사항이 운영 환경에 배포되기 전에 반드시 거쳐야 하는 단계는?", "answer": "테스트 단계" },
                    { "exam": "웹 서버의 한 종류로, 대규모 동시 접속 처리에 특화되어 있으며 리버스 프록시 기능으로도 널리 사용되는 것은?", "answer": "Nginx" },
                    { "exam": "소프트웨어 개발과 IT 운영을 통합하여, 애플리케이션의 개발부터 배포, 운영까지의 속도를 높이는 문화 및 방법론은?", "answer": "DevOps" },
                    { "exam": "애플리케이션 실행 환경을 이미지 형태로 생성하여, 어떤 환경에서든 동일한 실행을 보장하는 도커의 핵심 구성 요소는?", "answer": "도커 이미지" },
                    { "exam": "도커 이미지를 실행한 인스턴스로, 격리된 공간에서 애플리케이션이 동작하는 실체는?", "answer": "도커 컨테이너" },
                    { "exam": "형상 관리에서, 특정 항목이 언제, 왜, 누구에 의해 변경되었는지 추적하고 기록하는 활동은?", "answer": "형상 감사" },
                    { "exam": "자바 엔터프라이즈 에디션(Java EE) 스펙을 구현한 애플리케이션 서버들을 통칭하여 무엇이라고 하는가?", "answer": "Java EE 서버" },
                    { "exam": "운영체제 수준에서 프로세스를 격리하여, 가상 머신(VM)보다 가볍고 빠른 가상화 기술은?", "answer": "컨테이너 가상화" },
                    { "exam": "배포 과정에서 기존 서버를 중단하지 않고, 새 서버로 점진적으로 트래픽을 전환하는 방식은?", "answer": "롤링 배포" },
                    { "exam": "전체 사용자가 아닌, 특정 지역이나 특정 사용자 그룹에게만 새 버전을 먼저 배포하는 전략은?", "answer": "지역 기반 배포" },
                    { "exam": "Git에서 다른 브랜치의 특정 커밋 하나만 현재 브랜치로 가져오고 싶을 때 사용하는 명령어는?", "answer": "cherry-pick" },
                    { "exam": "Jenkins와 같은 CI/CD 도구에서, 전체 빌드-테스트-배포 과정을 정의한 스크립트 파일을 무엇이라고 하는가?", "answer": "파이프라인 스크립트" },
                    { "exam": "형상 관리 대상이 되는 소프트웨어의 각 단위를 무엇이라고 하는가?", "answer": "형상 항목" },
                    { "exam": "새 버전 배포 후 문제가 발견되어 이전 버전으로 되돌릴 때, DNS를 이용하여 트래픽을 이전 버전 환경으로 다시 보내는 전략은?", "answer": "블루-그린 롤백" },
                    { "exam": "배포 자동화의 가장 큰 기대효과로 보기 어려운 것은?", "answer": "개발자 코딩 능력 향상" },
                    { "exam": "Git에서 로컬에 존재하지 않는 원격 브랜치의 내용을 가져오고 싶을 때 사용하는 명령어는?", "answer": "fetch" }
                ]
            }
        ];

        // --- 상태 관리 ---
        let currentChapterIndex = null;
        let currentQuestionIndex = 0;
        let score = 0;
        let currentExams = [];

        // --- DOM 요소 ---
        const chapterSelectionScreen = document.getElementById('chapter-selection-screen');
        const chapterList = document.getElementById('chapter-list');
        const quizScreen = document.getElementById('quiz-screen');
        const resultScreen = document.getElementById('result-screen');
        const quizHeaderTitle = document.getElementById('quiz-header-title');
        const progressText = document.getElementById('progress-text');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const feedbackText = document.getElementById('feedback-text');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const scoreText = document.getElementById('score-text');
        const backToChaptersBtn = document.getElementById('back-to-chapters-btn');
        const restartQuizBtn = document.getElementById('restart-quiz-btn');
        const goToChaptersBtn = document.getElementById('go-to-chapters-btn');
        
        // --- 함수 ---

        /** 모든 화면을 숨기고 단원 선택 화면만 표시 */
        function showChapterSelection() {
            quizScreen.classList.add('hidden');
            resultScreen.classList.add('hidden');
            chapterSelectionScreen.classList.remove('hidden');
        }

        /** 단원 목록을 동적으로 생성 */
        function populateChapters() {
            chapterList.innerHTML = '';
            const processedQuizData = quizData; 

            processedQuizData.forEach((chapterData, index) => {
                const btn = document.createElement('button');
                btn.className = 'chapter-btn w-full p-6 bg-slate-50 text-left rounded-lg border-2 border-slate-200 hover:border-indigo-400';
                btn.innerHTML = `<h3 class="text-lg font-bold text-slate-800">${chapterData.chapter}</h3><p class="text-sm text-slate-500">${chapterData.exams.length} 문제</p>`;
                btn.onclick = () => startQuiz(index, processedQuizData);
                chapterList.appendChild(btn);
            });
        }

        /** 퀴즈 시작 */
        function startQuiz(chapterIndex, data) {
            currentChapterIndex = chapterIndex;
            currentExams = shuffleArray([...data[chapterIndex].exams]);
            currentQuestionIndex = 0;
            score = 0;

            chapterSelectionScreen.classList.add('hidden');
            resultScreen.classList.add('hidden');
            quizScreen.classList.remove('hidden');

            quizHeaderTitle.textContent = data[chapterIndex].chapter;
            loadQuestion();
        }

        /** 문제 로드 */
        function loadQuestion() {
            // 초기화
            optionsContainer.innerHTML = '';
            feedbackText.textContent = '';
            nextQuestionBtn.classList.add('hidden');

            const questionData = currentExams[currentQuestionIndex];
            
            progressText.textContent = `문제 ${currentQuestionIndex + 1} / ${currentExams.length}`;
            questionText.textContent = questionData.exam;

            // 보기 생성
            const options = generateOptions(questionData.answer, currentChapterIndex);
            options.forEach(optionText => {
                const btn = document.createElement('button');
                btn.className = 'option-btn w-full p-4 bg-white text-left rounded-lg border-slate-300 hover:bg-slate-50';
                btn.textContent = optionText;
                btn.onclick = (e) => selectAnswer(e.target, questionData.answer);
                optionsContainer.appendChild(btn);
            });
        }
        
        /** 정답을 포함한 보기 4개 생성 (오답은 해당 단원 내에서 랜덤 선택) */
        function generateOptions(correctAnswer, chapterIdx) {
            let options = [correctAnswer];
            // 현재 단원의 모든 정답 목록
            const chapterAnswers = quizData[chapterIdx].exams.map(ex => ex.answer);
            // 그 중에서 오답만 필터링
            const wrongAnswers = chapterAnswers.filter(ans => ans !== correctAnswer); 
            const uniqueWrongAnswers = [...new Set(wrongAnswers)];
            
            while (options.length < 4 && uniqueWrongAnswers.length > 0) {
                const randomIndex = Math.floor(Math.random() * uniqueWrongAnswers.length);
                options.push(uniqueWrongAnswers.splice(randomIndex, 1)[0]);
            }
             // 보기 수가 4개 미만일 경우 전체 데이터에서 추가
            if (options.length < 4) {
                 const allAnswers = quizData.flatMap(ch => ch.exams.map(ex => ex.answer));
                 const moreWrongAnswers = allAnswers.filter(ans => !options.includes(ans));
                 const uniqueMoreWrongAnswers = [...new Set(moreWrongAnswers)];
                 while(options.length < 4 && uniqueMoreWrongAnswers.length > 0) {
                    const randomIndex = Math.floor(Math.random() * uniqueMoreWrongAnswers.length);
                    options.push(uniqueMoreWrongAnswers.splice(randomIndex, 1)[0]);
                 }
            }

            return shuffleArray(options);
        }
        
        /** 배열 섞기 (Fisher-Yates shuffle) */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        /** 답안 선택 시 처리 */
        function selectAnswer(selectedButton, correctAnswer) {
            const buttons = optionsContainer.querySelectorAll('.option-btn');
            buttons.forEach(btn => {
                btn.classList.add('disabled'); // 모든 버튼 비활성화
                if (btn.textContent === correctAnswer) {
                    btn.classList.add('correct');
                }
            });

            if (selectedButton.textContent === correctAnswer) {
                score++;
                feedbackText.textContent = '👍';
                feedbackText.className = 'text-lg font-bold text-green-600 min-h-[28px]';
            } else {
                selectedButton.classList.add('incorrect');
                feedbackText.innerHTML = `그걸 틀리냐. <br>정답: <span class="font-bold">${correctAnswer}</span>`;
                feedbackText.className = 'text-base text-red-600 min-h-[24px]';
            }
            nextQuestionBtn.classList.remove('hidden');
        }

        /** 결과 화면 표시 */
        function showResult() {
            quizScreen.classList.add('hidden');
            resultScreen.classList.remove('hidden');
            const percentage = currentExams.length > 0 ? Math.round((score / currentExams.length) * 100) : 0;
            scoreText.innerHTML = `${score} / ${currentExams.length} <span class="text-2xl ml-2">(${percentage}%)</span>`;
        }

        // --- 이벤트 리스너 ---
        nextQuestionBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            if (currentQuestionIndex < currentExams.length) {
                loadQuestion();
            } else {
                showResult();
            }
        });

        backToChaptersBtn.addEventListener('click', showChapterSelection);
        goToChaptersBtn.addEventListener('click', showChapterSelection);
        restartQuizBtn.addEventListener('click', () => {
            startQuiz(currentChapterIndex, quizData);
        });
        
        // --- 초기 실행 ---
        populateChapters();

    </script>
</body>
</html>
